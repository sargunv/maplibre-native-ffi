#Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

#Lessons

## User Specified Lessons

- Don't fix lints, unless I explicitly ask you to fix a lint for your task.
- This project is intended to be a set of C bindings for using maplibre native.
- My goal is to eventually use it to make map apps in other languages, like Kotlin Native, Kotlin JVM, Rust, and so on on platforms like macOS, Linux, Windows, Android, and iOS.
- Our bindings are prefixed with `MLN_`. For example, `MLN_TypeName_methodName`.
- We manage C++ objects as `void *`.
- We write very modern C/C++, with clang-tidy for enforcement. This means `using`, `auto`, trailing return types, etc.
- Setter methods should use `set` prefix (e.g. `MLN_MapOptions_setSize`), not `with` prefix.
- Constructor/destructor pairs should use `new`/`delete` (e.g. `MLN_MapOptions_new`, `MLN_MapOptions_delete`), not `create`/`destroy`.
- Getter methods should not use `get` prefix (e.g. `MLN_MapOptions_size`, not `MLN_MapOptions_getSize`).
- Always run `just format` after making code changes to ensure consistent formatting.
- Never use `using namespace`. Always use qualified names.
- The full maplibre-native source is available in ./build/_deps/maplibre-native-src

## Cursor learned

- Project uses CMake as build system, with clang-format and clang-tidy for code quality
- Project uses justfile for common development tasks like building, formatting, and linting
- Each component should have unit tests to verify the bindings work correctly
- Tests are organized in a single executable with each component's tests in a separate file
- Test functions should be in an anonymous namespace and each test file should expose a run_*_tests() function

#Scratchpad

## Metal Renderer FFI Implementation Plan

Task: Implement Metal renderer FFI to allow rendering MapLibre maps to an MKTView

Components needed:
1. Metal Renderer Backend (MLN_MetalRendererBackend)
   - Will wrap mbgl::gfx::RendererBackend
   - Needs to integrate with Metal/MKTView
   - Manages the Metal device, command queue, etc.

2. Metal Renderer Frontend (MLN_MetalRendererFrontend)
   - Will wrap mbgl::RendererFrontend
   - Manages the renderer lifecycle
   - Handles updates and observer pattern
   - Similar structure to GLFWRendererFrontend

3. Metal Renderer (internal)
   - Created by the frontend
   - Handles actual rendering operations
   - Will be managed internally, not exposed in FFI

Implementation Steps:
[ ] 1. Create header files
   [ ] include/MetalRendererBackend.h
   [ ] include/MetalRendererFrontend.h

[ ] 2. Implement Metal Renderer Backend
   [ ] Basic Metal setup (device, command queue)
   [ ] Integration with MKTView
   [ ] Implementation of RendererBackend interface

[ ] 3. Implement Metal Renderer Frontend
   [ ] Constructor/destructor
   [ ] Update mechanism
   [ ] Observer pattern
   [ ] Render loop

[ ] 4. Create C FFI bindings
   [ ] MLN_MetalRendererBackend_new/delete
   [ ] MLN_MetalRendererFrontend_new/delete
   [ ] Other necessary methods

[ ] 5. Write tests
   [ ] Basic creation/destruction
   [ ] Update handling
   [ ] Observer pattern
   [ ] Rendering tests

Dependencies to investigate:
- Metal.framework
- MetalKit.framework
- QuartzCore.framework (for CAMetalLayer)
